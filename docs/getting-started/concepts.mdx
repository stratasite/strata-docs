# Core Concepts

Understanding the fundamental concepts of Strata's semantic layer.

## What is a Semantic Layer?

A semantic layer is an abstraction that sits between your raw database tables and business users. It translates business-friendly field names (like "Total Revenue") into optimized SQL queries against your physical database.

**Benefits:**
- **Self-service analytics**: Business users can explore data without writing SQL
- **Consistency**: Single source of truth for metrics and definitions
- **Performance**: Optimized query generation with cost-based routing
- **Security**: Centralized access control and data governance

:::info Git-Based Workflow
**All semantic models are version-controlled YAML files.** Unlike UI-based BI tools where changes are made through point-and-click interfaces:
- **Version control**: Full Git history for all changes
- **Code review**: PR-based workflows for model changes
- **Branching**: Test changes in branches before deploying to production
- **CI/CD**: Automated testing and deployment pipelines
- **Rollback**: Easy revert to any previous state

This makes Strata ideal for teams that value engineering rigor and want to treat their semantic layer as code.
:::

## Key Components

### Tables

Tables (`tbl.*.yml`) represent physical database tables with semantic metadata. They define:
- **Dimensions**: Categorical fields (e.g., Customer Name, Product Category)
- **Measures**: Aggregatable metrics (e.g., Total Sales, Average Order Value)
- **Cost**: Query optimization hint (lower cost = preferred)
- **Partitions**: Data availability constraints

**Example:**
```yaml
name: Store Sales
physical_name: store_sales
datasource: tpcds
cost: 100

fields:
  - type: dimension
    name: Store Name
    data_type: string
    expression:
      sql: s_store_name

  - type: measure
    name: Total Revenue
    data_type: decimal
    expression:
      sql: sum(ss_sales_price)
```

### Relationships

Relations (`rel.*.yml`) define how tables join together. They specify:
- **Left and right tables**: Which tables to join
- **Join condition**: SQL expression for the join
- **Cardinality**: Relationship type (one-to-one, one-to-many, many-to-one)

**Example:**
```yaml
datasource: tpcds

store_sales_store:
  left: Store Sales
  right: Store
  sql: left.ss_store_sk = right.s_store_sk
  cardinality: many_to_one
```

### Datasources

Datasources connect Strata to your databases. They support:
- **Multiple adapters**: PostgreSQL, Snowflake, MySQL, SQL Server, Athena, Trino, DuckDB, Druid
- **Tier configuration**: Hot (fast), Warm (moderate), Cold (archival)
- **Connection pooling**: Efficient query execution

## Core Design Principles

:::tip Unique Naming Principle — Design Philosophy
**Field names must be unique across your entire semantic layer.** Unlike other tools (Looker, dbt, Power BI, Tableau) that use namespaced fields like `table.field_name`, Strata enforces global uniqueness.

When you define a measure called "Total Revenue", that name cannot be used anywhere else in your project — not in another table, not as a dimension, nowhere.

**Benefits:**
- **Unambiguous references**: When a query asks for "Total Revenue", there's exactly one definition
- **Simpler compound measures**: Reference fields by name without table prefixes: `[Total Revenue] - [Total Cost]`
- **Consistent analytics**: Everyone uses the same metric definitions organization-wide
- **AI-friendly**: LLMs can understand your model without disambiguation

**Trade-offs:**
- You cannot have `orders.revenue` and `subscriptions.revenue` — you must use distinct names like `order_revenue` and `subscription_revenue`
- Naming becomes more important and requires upfront planning
- Larger projects may face naming challenges as the model grows

**Recommendation:** Establish naming conventions early (e.g., prefix patterns like `order_*`, `customer_*`) to avoid conflicts.
:::

:::danger No Many-to-Many Relationships
**Strata does not support many-to-many (`many_to_many`) relationships.** This is an intentional design constraint to ensure predictable query behavior.

**Why this limitation exists:**
- Prevents double-counting in aggregations (a common source of bugs)
- Forces explicit modeling that makes data relationships clearer
- Ensures consistent query results

**Workaround:**
If you need many-to-many relationships (e.g., Users ↔ Roles), create a **junction/bridge table** with two separate relationships:
- `Users → UserRoles` (one_to_many)
- `UserRoles → Roles` (many_to_one)

**Trade-off:** This requires additional YAML files and explicit modeling, but results in more maintainable and predictable semantic models.
:::

## How It Works

### 1. Model Definition

Data engineers define semantic models using YAML files:
- Table models describe fields and metadata
- Relationship models define joins
- Migrations track changes over time

### 2. Deployment

Models are deployed to a Strata server:
- YAML files are validated
- Semantic model is built
- Universe paths are generated (all possible query paths)

### 3. Query Planning

When a user creates a query:
- **Universe Resolution**: Planner finds optimal data paths
- **DAG Construction**: Builds query execution plan
- **SQL Generation**: Converts semantic query to optimized SQL
- **Execution**: Runs query against datasource

### 4. Result Delivery

Query results are:
- Cached for performance
- Formatted according to field definitions
- Returned to the user interface

## Key Terminology

**Dimension**: A categorical field used for grouping and filtering (e.g., "Product Category", "Customer Region")

**Measure**: An aggregatable metric (e.g., "Total Sales", "Order Count")

**Universe**: A data access path through the semantic model that can answer a query

**Cardinality**: The relationship type between tables (one-to-one, one-to-many, many-to-one)

**Cost**: A numeric value that influences table selection when multiple tables can answer the same question

**Snapshot Measure**: A measure that captures a value at a specific point in time (beginning or ending of period)

**Decorator**: A transformation applied to projections (e.g., date truncation, window functions, temporal comparisons)

**Partition**: A constraint on data availability (e.g., "table only contains last 24 months")

## Project Structure

A typical Strata project:

```
my-project/
├── project.yml              # Project metadata
├── datasources.yml          # Datasource configurations
├── .strata                  # Local secrets (gitignored)
├── models/                  # Semantic model files
│   ├── sales/
│   │   ├── tbl.orders.yml
│   │   ├── tbl.customers.yml
│   │   └── rel.sales.yml
│   └── inventory/
│       └── tbl.products.yml
├── migrations/              # Schema migrations
│   └── 20260101_rename_field.yml
└── tests/                   # Query validation tests
    └── revenue_positive.yml
```

## Workflow

1. **Initialize**: Create project with `strata init`
2. **Configure**: Add datasources with `strata datasource add`
3. **Model**: Create tables and relationships
4. **Test**: Validate with `strata audit` and test files
5. **Deploy**: Upload to server with `strata deploy`

## Next Steps

- Learn how to [create tables](/cli/tables)
- Understand [field types and expressions](/semantic-model/fields-and-types)
- Explore [relationships](/cli/relationships)
- Read about [advanced features](/advanced)
